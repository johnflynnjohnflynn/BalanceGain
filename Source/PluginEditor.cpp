/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "JFProcessor.h"
#include "JFEditor.h"


//==============================================================================
JFEditor::JFEditor (JFProcessor& p)
    : AudioProcessorEditor (&p),
      buttonAB ("A-B"),
      buttonCopyAB ("Copy"),
      processor (p)
{
    buttonAB.setColour (TextButton::textColourOffId, Colour (0xff404040));
    buttonAB.setColour (TextButton::buttonColourId, Colour (0xffa0a0a0));
    addAndMakeVisible (buttonAB);
    buttonAB.addListener (this);

    buttonCopyAB.setColour (TextButton::textColourOffId, Colour (0xff404040));
    buttonCopyAB.setColour (TextButton::buttonColourId, Colour (0xffa0a0a0));
    addAndMakeVisible (buttonCopyAB);
    buttonCopyAB.addListener (this);

    // Add GUI slider/label for every AudioProcessorParameter
    for (int i = 0; i < processor.numParams(); ++i)
    {
        const AudioParameterFloatStepped& param = processor.getParam(i);

        Slider* newSlider = new Slider (param.name);
        jassert (newSlider);
        sliders.add (newSlider);

        newSlider->setSliderStyle (Slider::LinearHorizontal);
        newSlider->setTextBoxStyle (Slider::TextBoxRight,false,unit*8,unit*2);
        newSlider->setColour (Slider::thumbColourId, Colours::silver);
        newSlider->setColour (Slider::textBoxTextColourId, Colour (0xff404040));
        newSlider->setColour (Slider::textBoxBackgroundColourId, Colour (0xff909090));
        
        addAndMakeVisible (newSlider);

        newSlider->addListener (this);

        const String name = param.name;
        Label* aLabel = new Label (name, name);
        jassert (aLabel);
        labels.add (aLabel);

        aLabel->setJustificationType (Justification::centredLeft);
        aLabel->setEditable (false, false, false);
        aLabel->setColour (Label::textColourId, Colour (0xff404040));
        aLabel->setColour (TextEditor::textColourId, Colours::black);
        aLabel->setColour (TextEditor::backgroundColourId,Colour (0x00000000));

        addAndMakeVisible (aLabel);
    }
    jassert (sliders.size() == labels.size());

    updateSlidersFromProcParams();  // set slider values and ranges

    const int numRows = sliders.size();
    const int height = margin
                     + heightButtonsAB
                     + numRows * 2 * heightComponent
                     + margin / 2;
    setSize (width, height);        // must be set before xtor finished

    startTimerHz (30);
}

JFEditor::~JFEditor()
{
}

//==============================================================================
void JFEditor::paint (Graphics& g)
{
    g.fillAll (Colours::grey);
}

void JFEditor::resized()
{
    buttonAB.setBounds(margin + 4,
                       margin + 4,
                       buttonABWidth,
                       heightComponent);
    buttonCopyAB.setBounds(margin + buttonABWidth + margin,
                           margin + 4,
                           buttonCopyABWidth - 4,
                           heightComponent);

    for (int i = 0; i < sliders.size(); ++i)
    {
        jassert (sliders[i]);
        sliders[i]->setBounds(margin,
                              margin + heightButtonsAB + i * 2 * heightComponent + 16,
                              widthComponent,
                              heightComponent);
    }
    for (int i = 0; i < labels.size(); ++i)
    {
        jassert (labels[i]);
        labels[i]->setBounds (margin,
                              margin + heightButtonsAB + i * 2 * heightComponent,
                              widthComponent,
                              heightComponent);
    }
}

//==============================================================================
void JFEditor::buttonClicked (Button* clickedButton)
{
    if (clickedButton == &buttonAB) processor.toggleABState();
    if (clickedButton == &buttonCopyAB) processor.copyABState();
}

//==============================================================================
void JFEditor::sliderValueChanged (Slider* movedSlider)
{
    jassert (movedSlider);
    setProcParamFromSlider (*movedSlider);
}

//==============================================================================
void JFEditor::timerCallback()
{
    processor.updateStepSlaveRanges();
    updateSlidersFromProcParams();
}

//==============================================================================
void JFEditor::setProcParamFromSlider (const Slider& slider) const
{
    int i = sliders.indexOf (&slider);
    const float sliderVal = (float) slider.getValue();

    processor.setParam (i, sliderVal);
}

//==============================================================================
void JFEditor::updateSlidersFromProcParams()
{
    for (int i = 0; i < processor.numParams(); ++i) {
        const auto& p = processor.getParam(i);

        jassert (i < sliders.size());
        jassert (sliders[i]);
        sliders[i]->setRange (p.range.start,
                              p.range.end,
                              p.range.interval);
        sliders[i]->setValue ((double) p.get(), dontSendNotification);
    }
}


//==============================================================================
// Non-member helpers
//==============================================================================
void printSlidersParams(const JFProcessor& processor,
                        const OwnedArray<Slider>& sliders)
{
    std::ostringstream message;

    for (int i = 0; i < processor.numParams(); ++i) {
        jassert (i < sliders.size());
        jassert (sliders[i]);
        message << "Sliders["<<i<<"] " << sliders[i]->getValue()
                << " params["<<i<<"] " << processor.getParam(i).get() << "\n";
    }

    Logger::outputDebugString ((String) message.str());
}
